

/*****************************************************************************
      Include files
*****************************************************************************/
/* Stack includes */
#include <Api.h>
#include <JIP.h>
#include <6LP.h>
/* JenOS includes */
#include <dbg.h>
#include <dbg_uart.h>
/* Application includes */
#include "Config.h"
#include "DeviceDefs.h"
#include "Exception.h"
#include "MibDio.h"
#include "MibDioControl.h"

/**********************************************************************************************************
   MIB structures
**********************************************************************************************************/
#if MK_BLD_MIB_DIO_CONTROL
extern tsMibDioControl	 sMibDioControl;
extern thJIP_Mib		 hMibDioControl;
#endif



/**********************************************************************************************************
    Local Variables
**********************************************************************************************************/
PRIVATE uint8   u8TickQueue;											/* Tick timer queue 			*/
PRIVATE uint8   u8Tick;	   												/* Tick counter 				*/
PUBLIC  uint32  u32Second;  												/* Second counter 				*/
PRIVATE uint8   bTog=0;
PRIVATE uint8   turn_flag = 1;
PRIVATE uint8   i2c_counter = 0;
PRIVATE bool_t   bInitialised;
PRIVATE bool_t   bSleep;
/**********************************************************************************************************
    Other data
**********************************************************************************************************/
PRIVATE uint8   *pTxBuf ;
PRIVATE uint8   *pRxBuf ;

PRIVATE uint8  rxdata[1000]={0};
PRIVATE	uint16 rxdata_count = 0 ;
PRIVATE uint8 received_data_uart1[40];
PRIVATE uint8 received_num_uart1 =1;
PRIVATE uint8    data_to_send[1000]={0};
PRIVATE uint8 start_juge1 =0;
PRIVATE uint64 u64childAddr;
PRIVATE uint8 child_leave[15];
/**********************************************************************************************************
    Exported Functions
**********************************************************************************************************/
PUBLIC void Device_vInit(bool_t bWarmStart);
PUBLIC void Node_eJipInit(void);
PRIVATE void delay_16ms(uint8 t);

#define UART E_AHI_UART_1
PRIVATE void vPutChar(uint8 c) ;
PRIVATE void vUartInit(void);

#define LED                             (1 << 17)

//数据接收端， 首先需要在相应的 PORT进行绑定， 然后在v6LP_DataEvent事件中接收E_DATA_RECEIVED消息。
#define PROTOCOL_PORT				 	 (1190)

PRIVATE bool_t          	  bProtocolSocket;
PRIVATE int					  iProtocolSocket;
PRIVATE ts6LP_SockAddr 		  s6lpSockAddrLocal;
PRIVATE void Protocol_vSendTo(ts6LP_SockAddr *ps6lpSockAddr, uint8 *pu8Data, uint16 u16DataLen);

/**********************************************************************************************************
	远程节点地址
**********************************************************************************************************/
MAC_ExtAddr_s sParentNodeAddr;
MAC_ExtAddr_s sLocalNodeAddr;
MAC_ExtAddr_s sChildNodeAddr;
MAC_ExtAddr_s sCommNodeAddr;

PRIVATE void Protocol_vOpenSocket(void)
{

		iProtocolSocket = i6LP_Socket(E_6LP_PF_INET6,
									  E_6LP_SOCK_DGRAM,
									  E_6LP_PROTOCOL_ONLY_ONE);

		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\n iProtocolSocket %d", iProtocolSocket);

		if (iProtocolSocket == -1)
		{
			DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\n get iProtocolSocket failed ");
		}
		/* Registered socket ? */
		else
		{
			int			   iBindResult;
			int 		   iSocketAddGroupAddr;

			/* Socket has been opened */
			bProtocolSocket = TRUE;

			/* Get own address */
			(void) i6LP_GetOwnDeviceAddress(&s6lpSockAddrLocal, FALSE);
			/* Set socket port in address */
			s6lpSockAddrLocal.sin6_port = PROTOCOL_PORT;

			/* Bind socket to address (including application port) */
			iBindResult = i6LP_Bind(iProtocolSocket, &s6lpSockAddrLocal, sizeof(ts6LP_SockAddr));

			/* Failed ? */
			if (iBindResult != 0)
			{
				DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\n i6LP_Bind Failed");

			}

			/* Bind the group address to the socket */
//			iSocketAddGroupAddr = i6LP_SocketAddGroupAddr(iProtocolSocket, &s6lpSockAddrNetwork.sin6_addr);
//
//			if (iSocketAddGroupAddr == -1)
//			{
//				DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\n i6LP_SocketAddGroupAddr failed");
//			}
		}


}

/**********************************************************************************************************
** Function name:     SendDataToRemote
** Descriptions:      发送数据范例函数

**********************************************************************************************************/
PRIVATE int SendDataToRemote(MAC_ExtAddr_s *psMacAddr, uint8 *pu8Data, uint16 u16DataLen)
{
    uint8 i = 0;
    ts6LP_SockAddr s6LP_SockAddr;                                       /* 定义ts6LP_SockAddr             */
    EUI64_s  sIntAddr;
    int iGetDataBufferResult;
    int iSendToResult;
    uint8 *pu8Buffer;
                                                                        /* vJIP_StackEvent赋值                */
    memset(&s6LP_SockAddr, 0, sizeof(ts6LP_SockAddr));                  /* 清空s6LP_SockAddr结构体内存值    */
    i6LP_CreateInterfaceIdFrom64(&sIntAddr, (EUI64_s *) psMacAddr);     /* 建立接口ID                   */
    i6LP_CreateLinkLocalAddress (&s6LP_SockAddr.sin6_addr, &sIntAddr);  /* 建立连接本地地址                 */
    /*
     * Complete full socket address
     */
    s6LP_SockAddr.sin6_family = E_6LP_PF_INET6;                         /* 经常设置为E_6LP_PF_INET6      */
    s6LP_SockAddr.sin6_flowinfo =0;                                     /* 包含flow信息                     */
    s6LP_SockAddr.sin6_port = PROTOCOL_PORT;                            /* IPV6端口号                  */
    s6LP_SockAddr.sin6_scope_id =0;                                     /* 包含scope信息*/

    /* Try to get a data buffer */
    iGetDataBufferResult = i6LP_GetDataBuffer(&pu8Buffer);

    if (iGetDataBufferResult == -1)
    {
        DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nFAIL1", 0);
        return -2;
    }
    else
    {
        memcpy(pu8Buffer, pu8Data, u16DataLen);
        /* Transmit packet */
        iSendToResult = i6LP_SendTo(iProtocolSocket, pu8Buffer, u16DataLen, 0, &s6LP_SockAddr, sizeof(ts6LP_SockAddr));

        if (iSendToResult == -1)
        {
            DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nFAIL2", 0);
            return -1;
        }
        else
        {
            DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nSUCCESS", 0);
            return 0;
        }
    }
}
/**********************************************************************************************************
** Function name:     vJIP_Remote_DataSent
** Descriptions:      设置远程数据请求
** Input parameters:  ts6LP_SockAddr： 地址参数
**             		  teJIP_Status:  请求状态，E_JIP_OK请求成功，否则失败
** Output parameters: none
** Returned value:          none
**********************************************************************************************************/
PUBLIC void vJIP_Remote_DataSent(ts6LP_SockAddr *psAddr,
									   teJIP_Status eStatus)
{
	if (eStatus == E_JIP_OK) {
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\nMib Request Send Success");
	} else {
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\nMib Request Send Failed");
	}
}
/**********************************************************************************************************
** Function name:    vJIP_Remote_SetResponse
** Descriptions:     设置远程数据响应
** Input parameters: *psAddr: 地址参数
**			   		 u8Handle: 句柄
**			   		 u8MibIndex:MIB索引
**			   		 u8VarIndex:MIB变量索引
**             		 eStatus:  响应状态，E_JIP_OK请求成功，否则失败
** Output parameters: none
** Returned value:          none
**********************************************************************************************************/
PUBLIC WEAK void vJIP_Remote_SetResponse(ts6LP_SockAddr *psAddr,
        uint8 u8Handle,
        uint8 u8MibIndex,
        uint8 u8VarIndex,
        teJIP_Status eStatus)
{
	if (eStatus == E_JIP_OK) {
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\nMib Request Process Success");
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\nu8MibIndex:%d",u8MibIndex);
	} else {
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\nMib Request Process Failed");
	}
}

/**********************************************************************************************************
** Function name:     AppColdStart
** Descriptions:      冷启动
** Input parameters:  none
** Output parameters: none
** Returned value:          none
**********************************************************************************************************/
PUBLIC void AppColdStart(void)
{
	/*
	 * Initialise device
	 */
	Device_vInit(FALSE);
}

/**********************************************************************************************************
** Function name:     AppWarmStart
** Descriptions:      热启动， memory hold 休眠唤醒的时候入口
** Input parameters:  none
** Output parameters: none
** Returned value:          none
**********************************************************************************************************/
PUBLIC void AppWarmStart(void)
{
	/*
	 * Initialise device
	 */
	Device_vInit(TRUE);
}

/**********************************************************************************************************
** Function name:     Device_vInit
** Descriptions:      设备初始化函数
** Input parameters:  bWarmStart：TRUE热启动，FALSE冷启动
** Output parameters: none
** Returned value:          none
**********************************************************************************************************/
PUBLIC void Device_vInit(bool_t bWarmStart)
{
	v6LP_InitHardware();
	vAHI_HighPowerModuleEnable(TRUE,TRUE);

	/* 初始化硬件		 		*/
	while(bAHI_Clock32MHzStable() == FALSE);  //set clock 32MHz ?? D							/* 等待时钟稳定 					*/
	if (FALSE == bWarmStart)											/* 判断是否冷启动 				*/
	{
		Exception_vInit();												/* Initialise exception handler */
		/*
		 * Initialise all DIO as outputs and drive low
		 */
		vAHI_DioSetDirection(0, 0xFFFFFFFE);
		vAHI_DioSetOutput(0xFFFFFFFE, 0);

	}

	#ifdef DBG_ENABLE													/* 是否开启debug 						*/
	{
		DBG_vUartInit(DEBUG_UART, DEBUG_BAUD_RATE);						/* Initialise debugging 		*/
		/*
		 * Disable the debug port flow control lines to turn off LED2
		 */
		vAHI_UartSetRTSCTS(DEBUG_UART, FALSE);
	}
	#endif


	if (bWarmStart) {
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\nbWarmStart");
	} else {
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\r\nbColdStart");
	}

	if (FALSE == bWarmStart)											/* Cold start ? 				*/
	{
		u8TickQueue = 0;												/* Reset the tick queue 		*/
		/*
		 * Initialise PDM
		 */
		PDM_vInit(0, 63, 64, (OS_thMutex)1, /* Mutex */
					NULL, NULL, NULL);

		MibDioControl_vInit(hMibDioControl, &sMibDioControl);          /* 初始化MIB */

		MibDioControl_vRegister();										/* 注册MIB */
		Node_eJipInit();												/* 初始化协议栈 					*/

		u32AHI_Init();

		vUartInit();
	}



	while (1) {                                                           /*主循环*/
				v6LP_Tick();
				vAHI_WatchdogRestart();
		}


}


/**********************************************************************************************************
** Function name:     v6LP_ConfigureNetwork
** Descriptions:      设置其他网络参数
** Input parameters:  none
** Output parameters: *psNetworkConfigData：Pointer to structure containing values to be set
** Returned value:    none
**********************************************************************************************************/
PUBLIC void v6LP_ConfigureNetwork(tsNetworkConfigData *psNetworkConfigData)
{
	tsSecurityKey netSecurityKey;
	uint16 mode;
	DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nv6LP_ConfigureNetwork()");

	v6LP_EnableSecurity();												/* 使能安全密码 					*/

#define STACK_MODE_STANDALONE  0x0001
#define STACK_MODE_COMMISSION  0x0002

	vApi_SetStackMode(STACK_MODE_COMMISSION);							/* 设置为COMMISSION模式			*/
	mode = u16Api_GetStackMode();										/* 获取协议栈模式 				*/
	DBG_vPrintf(DEBUG_NODE_VARS, "\nStackMode is 0x%04x", mode);

												/* 定义了协调器 					*/
	netSecurityKey.u32KeyVal_1 = 0x10101010;
	netSecurityKey.u32KeyVal_2 = 0x10101010;
	netSecurityKey.u32KeyVal_3 = 0x10101010;
	netSecurityKey.u32KeyVal_4 = 0x10101010;

	vApi_SetNwkKey(0, &netSecurityKey);									/* 设置为网络密码 				*/
	DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nCoordinator network key Load");

	if (bJnc_SetJoinProfile(3, NULL)) {									/* 设置加入配置参数 				*/
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nJoinProfile Successfully");
	} else {
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nJoinProfile Fail");
	}

	if (bJnc_SetRunProfile(3, NULL)) {									/* 设置运行配置参数 				*/
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nRunProfile Successfully");
	} else {
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nRunProfile Fail");
	}



}

/**********************************************************************************************************
** Function name:     v6LP_DataEvent
** Descriptions:      数据事件
** Input parameters:  iSocket：   Socket on which packet received
**             		  eEvent：   Data event
**             		  *psAddr：   Source address (for RX) or destination (for TX)
**             		  u8AddrLen：   Length of address
** Output parameters: none
** Returned value:          none
**********************************************************************************************************/
PUBLIC void v6LP_DataEvent(int iSocket, te6LP_DataEvent eEvent,
                           ts6LP_SockAddr *psAddr, uint8 u8AddrLen)
{
	DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nv6LP_DataEvent(%d)", eEvent);		/* Debug 						*/
	switch (eEvent)														/* Which event ? 				*/
	{
		case E_DATA_RECEIVED:											/* Data received ? 				*/
		{
			DBG_vPrintf(DEBUG_DEVICE_FUNC, "E_DATA_RECEIVED");
			int					iRecvFromResult;
			ts6LP_SockAddr 	    s6lpSockAddr;
			uint8		       u8SockAddrLen;
			uint8    		  au8Data[256];
			uint16            au8DataLen;
			uint16            *pau8DataLen;
			void              *pvData = (void *) au8Data;

			pau8DataLen = &au8DataLen;
			i6LP_GetNextPacketSize(iSocket, pau8DataLen);
			/* Read 6LP packet */
			iRecvFromResult = i6LP_RecvFrom(iSocket, au8Data, au8DataLen, 0, &s6lpSockAddr, &u8SockAddrLen);
			/* Error ? */
			if (iRecvFromResult == -1)
			{

			}
			/* Success ? */
			else
			{
			    int k;
                for(k = 0; k < au8DataLen; k++)
                {
                    vPutChar(au8Data[k]);
                }

				if(turn_flag == 0)
				{
				    vAHI_DioSetOutput(0, LED);
					turn_flag = 1;
				}
				else
				{
					vAHI_DioSetOutput(LED, 0);
					turn_flag = 0;
				}
			}
		}
		break;
		case E_IP_DATA_RECEIVED:										/* IP data received ? 			*/
		case E_6LP_ICMP_MESSAGE:										/* 6LP ICMP message ? 			*/
		{
			/*
			 * Discard 6LP packets as only interested in JIP communication
			 */
			i6LP_RecvFrom(iSocket, NULL, 0, 0, NULL, NULL);
		}
		break;
		default:
		{
			;															/* Do nothing 					*/
		}
		break;
	}
}

/**********************************************************************************************************
** Function name:     vJIP_StackEvent
** Descriptions:      协议栈事件
** Input parameters:  eEvent：   Stack event
**             		  *pu8Data：   Additional information associated with event
**             		  u8AddrLen：   Length of additional information
** Output parameters: none
** Returned value:    none
**********************************************************************************************************/
PUBLIC void vJIP_StackEvent(te6LP_StackEvent eEvent, uint8 *pu8Data, uint8 u8DataLen)
{
	bool_t bPollNoData;
	tsSecurityKey netSecurityKey;

	switch (eEvent) {
	case E_STACK_STARTED:												/* 协议栈启动，协调器建立网络 		*/
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_STARTED", eEvent);
		memcpy((uint8 *)&sLocalNodeAddr, (uint8 *)&(((tsNwkInfo *)pu8Data)->sLocalAddr), 8);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nmy mac:%08x", ((tsNwkInfo *)pu8Data)->sLocalAddr.u32H);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "%08x", ((tsNwkInfo *)pu8Data)->sLocalAddr.u32L);
		Protocol_vOpenSocket();    //发送方不需要打开 Socket.  接收方需要打开socket
		vAHI_DioSetOutput(0, LED);
		break;
	case E_STACK_JOINED:												/* Network is now up 			*/
		/*
		 * 将父节点的mac地址保存到sCommNodeAddr，并打印。
		 */
		memcpy((uint8 *)&sParentNodeAddr, (uint8 *)&(((tsNwkInfo *)pu8Data)->sParentAddr), 8);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_JOINED", eEvent);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nmy parent's mac:%08x", ((tsNwkInfo *)pu8Data)->sParentAddr.u32H);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "%08x", ((tsNwkInfo *)pu8Data)->sParentAddr.u32L);

		break;
	case E_STACK_NODE_JOINED:
		/*
		 * 将子节点的mac地址保存到sCommNodeAddr，并打印。
		 */
		memcpy((uint8 *)&sChildNodeAddr, (uint8 *)&(((tsAssocNodeInfo *)pu8Data)->sMacAddr), 8);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_NODE_JOINED", eEvent);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\njoin node mac:%08x", ((tsAssocNodeInfo *)pu8Data)->sMacAddr.u32H);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "%08x", ((tsAssocNodeInfo *)pu8Data)->sMacAddr.u32L);
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nProtocol_vOpenSocket()", eEvent);

		break;
	case E_STACK_NODE_LEFT:

	    memcpy((uint8 *)&sChildNodeAddr, (uint8 *)&(((tsAssocNodeInfo *)pu8Data)->sMacAddr), 8);
	    u64childAddr = (((uint64)(sChildNodeAddr.u32H)) << 32) + sChildNodeAddr.u32L;

	    DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_NODE_LEFT", eEvent);

        child_leave[0]='C';
        child_leave[1] = (uint8)((u64childAddr >> 56) );
        child_leave[2] = (uint8)((u64childAddr >> 48) );
        child_leave[3] = (uint8)((u64childAddr >> 40) );
        child_leave[4] = (uint8)((u64childAddr >> 32) );
        child_leave[5] = (uint8)((u64childAddr >> 24) );
        child_leave[6] = (uint8)((u64childAddr >> 16) );
        child_leave[7] = (uint8)((u64childAddr >> 8)  );
        child_leave[8] = (uint8)(u64childAddr);
        child_leave[9]='L';

        uint8 n = 5, num;
        while(n>0)
        {
          n=n-1;
          for(num=0;num<10;num++)
          {
              vPutChar(child_leave[num]);
          }
        }

		break;
	case E_STACK_TABLES_RESET:
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_TABLES_RESET", eEvent);
		break;
	case E_STACK_RESET:
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_RESET", eEvent);
		break;
	case E_STACK_POLL:
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_POLL", eEvent);
		te6LP_PollResponse ePollResponse;
		ePollResponse = *((te6LP_PollResponse *) pu8Data);				/* Cast response			 */
		DBG_vPrintf(DEBUG_DEVICE_FUNC, " POLL %d", ePollResponse);
		switch (ePollResponse)
		{
			case E_6LP_POLL_DATA_READY:									/* Got some data ? 			*/
			{
				bSleep = FALSE;
				DBG_vPrintf(DEBUG_DEVICE_FUNC, " DATA_READY");
				/*
				 * Poll again in case there is more
				 */
				ePollResponse = e6LP_Poll();
				DBG_vPrintf(DEBUG_DEVICE_FUNC, "\ne6LP_Poll() = %d", ePollResponse);
			}
			break;
			default:													/* Others ? 				*/
			{
				/*
				 * Network up - set flag to indicate polled but no data
				 */
				bSleep = TRUE;
			}
			break;
		}
		break;
	case E_STACK_NODE_JOINED_NWK:
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_NODE_JOINED_NWK", eEvent);
		break;
	case E_STACK_NODE_LEFT_NWK:
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_NODE_LEFT_NWK", eEvent);
		break;
	case E_STACK_NODE_AUTHORISE:
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_NODE_AUTHORISE", eEvent);
		break;
	case E_STACK_ROUTE_CHANGE:
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_ROUTE_CHANGE", eEvent);
		break;
	case E_STACK_GROUP_CHANGE:
		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_GROUP_CHANGE", eEvent);
		break;
//	case E_STACK_GATEWAY_STARTED:
//		DBG_vPrintf(DEBUG_DEVICE_FUNC, "\nE_STACK_GATEWAY_STARTED", eEvent);
//		break;
	default:
		break;
	}
}

/**********************************************************************************************************
** Function name:     v6LP_PeripheralEvent
** Descriptions:     外设事件
** Input parameters:  u32Device：   Device that caused peripheral event
**             		  u32ItemBitmap：   Events within that peripheral
** Output parameters: none
** Returned value:    none
**********************************************************************************************************/
PUBLIC void v6LP_PeripheralEvent(uint32 u32Device, uint32 u32ItemBitmap)
{
    uint32  AddrH, AddrL;
	/*
	 * Tick Timer is run by stack at 10ms intervals    协议栈将自动产生一个10ms间隔的tick timer中断。  所以如果自己设定tick timer会无效。
	 */
	if (u32Device == E_AHI_DEVICE_TICK_TIMER)
	{
		if (bInitialised == TRUE)										/* Initialised ? 				*/
		{
			if (u8TickQueue < 100) u8TickQueue++;						/* Increment pending ticks 		*/
		}

		/**********************************************************dong test ********************/
		i2c_counter++;

   }
	else if (u32Device == E_AHI_DEVICE_UART1)
	{
	    uint8  received_char_uart1;
	    received_char_uart1 = u8AHI_UartReadData(UART);
        if((start_juge1 == 0) && (received_char_uart1 == 'S'))
        {
            start_juge1 = 1;
            received_data_uart1[0] = received_char_uart1;
        }
        else
        {
            if(start_juge1 == 1)
            {
                 received_data_uart1[received_num_uart1] = received_char_uart1;
                 received_num_uart1 = received_num_uart1 + 1;

                 if(received_num_uart1 == 35)
                 {
                     start_juge1 = 0;
                     received_num_uart1 = 1;
                     if((received_data_uart1[0] == 'S') && (received_data_uart1[34] == 'E'))
                     {
                        AddrH = ((uint32)(received_data_uart1[3])) << 24;
                        AddrH = AddrH | (((uint32)(received_data_uart1[4])) << 16);
                        AddrH = AddrH | (((uint32)(received_data_uart1[5])) << 8 );
                        AddrH = AddrH |  ((uint32)(received_data_uart1[6]));

                        AddrL = ((uint32)(received_data_uart1[7])) << 24;
                        AddrL = AddrL | (((uint32)(received_data_uart1[8])) << 16);
                        AddrL = AddrL | (((uint32)(received_data_uart1[9])) << 8 );
                        AddrL = AddrL |  ((uint32)(received_data_uart1[10]));

                        sCommNodeAddr.u32H = AddrH;
                        sCommNodeAddr.u32L = AddrL;

                        SendDataToRemote(&sCommNodeAddr, received_data_uart1, 35);
                      }
               }

            }
              else
               {
                  start_juge1 = 0;
               }
         }
	}
}



/**********************************************************************************************************
** Function name:     Node_eJipInit
** Descriptions:      初始化协议栈
** Input parameters:  none
** Output parameters: none
** Returned value:    none
**********************************************************************************************************/
PUBLIC void Node_eJipInit(void)
{
	teJIP_Status     eStatus;
	DBG_vPrintf(DEBUG_NODE_FUNC, "\nNode_eJipInit()");

	PUBLIC	tsJIP_InitData sJipInitData;								/* Jip initialisation structure */

	/*
	 *  配置JIP
	 */
	sJipInitData.u64AddressPrefix       = CONFIG_ADDRESS_PREFIX; 		/* 配置WPAN内IPv6地址的前缀，		*/
																		/* 只有协调器才需要配置			*/
	sJipInitData.u32Channel				= CONFIG_SCAN_CHANNELS;     	/* 指定所用的信道号或配置所 		*/
																		/* 要扫描的信道号		  		*/

	sJipInitData.u16PanId				= CONFIG_PAN_ID;
	/*
	 *  配置最大的IP包大小：最大数据量+40，大小在0或256~1280，若为0则是设置为1280
	 */
	sJipInitData.u16MaxIpPacketSize		= 0;
	sJipInitData.u16NumPacketBuffers	= 2;    						/* Number of IP packet buffers 	*/
	sJipInitData.u8UdpSockets			= 2;           					/* Number of UDP sockets 		*/
																		/* supported 					*/
	sJipInitData.eDeviceType			= E_JIP_DEVICE_COORDINATOR;             	/* Device type (C, R, or ED) 	*/

	sJipInitData.u32RoutingTableEntries	= CONFIG_ROUTING_TABLE_ENTRIES; /* Routing table size (not ED) */

	/*
	 *  每个节点都有一个Device ID用于识别设备的类型，属于同一设备类型的设备具有相同的MIBs和相应的MIB变量
	 *  Device ID由两部分构成：31~16为厂商ID，15~0为产品ID
	 *  厂商ID的最高位用于识别剩余的15位是否是有效ID，若最高位为0则为无效ID，在开发阶段建议最高位设置为0
	 */
	sJipInitData.u32DeviceId			= MK_JIP_DEVICE_ID;
	sJipInitData.u8UniqueWatchers		= CONFIG_UNIQUE_WATCHERS;
	sJipInitData.u8MaxTraps				= CONFIG_MAX_TRAPS;
	sJipInitData.u8QueueLength 			= CONFIG_QUEUE_LENGTH;
	sJipInitData.u8MaxNameLength		= CONFIG_MAX_NAME_LEN;			/* 配置节点MIB的描述名变量的大小	*/
	sJipInitData.u16Port				= JIP_DEFAULT_PORT;				/* 配置接收JIP数据包的UDP端口号	*/
	sJipInitData.pcVersion 				= MK_VERSION;

	DBG_vPrintf(DEBUG_NODE_VARS, "\n\tsJipInitData.u32Channel             = 0x%08x", sJipInitData.u32Channel);
	DBG_vPrintf(DEBUG_NODE_VARS, "\n\tsJipInitData.u16PanId               = 0x%04x", sJipInitData.u16PanId);
	DBG_vPrintf(DEBUG_NODE_VARS, "\n\tsJipInitData.eDeviceType            = %d",     sJipInitData.eDeviceType);
	DBG_vPrintf(DEBUG_NODE_VARS, "\n\tsJipInitData.u32RoutingTableEntries = %d",     sJipInitData.u32RoutingTableEntries);
	DBG_vPrintf(DEBUG_NODE_VARS, "\n\tsJipInitData.u32DeviceId            = 0x%08x", sJipInitData.u32DeviceId);
	DBG_vPrintf(DEBUG_NODE_VARS, "\n\tsJipInitData.pcVersion              = '%s'",   sJipInitData.pcVersion);

	DBG_vPrintf(DEBUG_NODE_FUNC, "\neJIP_Init()");

	eStatus = eJIP_Init(&sJipInitData);									/* Initialise JIP 				*/

	if (eStatus != E_JIP_OK) {
		DBG_vPrintf(DEBUG_NODE_FUNC, "\nFailed to initialise JenNet-IP stack");
		while(1);
	}
	v6LP_SetPacketDefragTimeout(1);										/* Set 1 second defrag timeout 	*/
}

PRIVATE void vPutChar (uint8 c)
{
	while (!(u8AHI_UartReadLineStatus(UART) & E_AHI_UART_LS_THRE));
		vAHI_UartWriteData(UART, c);
	while ((u8AHI_UartReadLineStatus(UART) & (E_AHI_UART_LS_THRE | E_AHI_UART_LS_TEMT))
			!= (E_AHI_UART_LS_THRE | E_AHI_UART_LS_TEMT));
}
PRIVATE void vUartInit (void)
{
	#if (UART == E_AHI_UART_0)
	vAHI_UartSetRTSCTS(UART, FALSE); /* Disable use of CTS/RTS */
	#endif
	bAHI_UartEnable(E_AHI_UART_1,*pTxBuf,1000,*pRxBuf,1000);
	vAHI_UartSetLocation(UART,TRUE);
	vAHI_UartEnable(UART);
	vAHI_UartSetControl(E_AHI_UART_1, E_AHI_UART_EVEN_PARITY, E_AHI_UART_PARITY_DISABLE, E_AHI_UART_WORD_LEN_8, E_AHI_UART_1_STOP_BIT, E_AHI_UART_RTS_HIGH);
	vAHI_UartReset(UART, /* 复位收发FIFO */
			TRUE,
			TRUE);
	vAHI_UartSetBaudRate(UART, E_AHI_UART_RATE_9600); /* 设置波特率*/
	vAHI_UartSetInterrupt(UART, FALSE, FALSE, FALSE, TRUE, E_AHI_UART_FIFO_LEVEL_1); /* 关闭中断 */
	vInitPrintf((void *)vPutChar);
}

PRIVATE void delay_16ms(uint8 t)
{
	uint16 i = 0;
	uint16 j = 0;
	uint8 delay_num = 0;

	for(i=0;i<100;i++)
    {
    	for(j=0;j<(10*t);j++)
    	{
    		//_nop_();
    		if(delay_num == 1) delay_num = 0;
    		else delay_num = 1 ;
    	}
    }
}



/********************************************************************************************************
	END OF FILE
********************************************************************************************************/
